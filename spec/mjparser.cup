package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PLUS , RPAREN , EQUAL , SEMI , RETURN , LPAREN , COMMA , PROG , PRINT
 , VOID , MINUS , MUL , DIV , MOD , LBRACK , RBRACK , READ , NEW , PLUS_PLUS , CONST ,
 MINUS_MINUS , LBRACE , RBRACE , PLUS_EQUAL , MINUS_EQUAL , MUL_EQUAL , DIV_EQUAL , MOD_EQUAL , CHAR;
terminal Integer NUMBER ;
terminal Boolean BOOL ;
terminal String IDENT ;

nonterminal MethodDeclList, VarDecl , ConstDecl ;
nonterminal FormalParamList, FormalParamDecl, FormPars ;
nonterminal StatementList, Statement, Addop , ArrayBracks , FormalParamListExtended;
nonterminal DesignatorStatement, Minus, VarDeclListExtended ,
AddopTermList, MulopFactorList, ConstType , ConstDeclListExtended ,
Assignop, AddopLeft, AddopRight, Mulop, MulopLeft, MulopRight;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName ;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Expr , ConstVarDeclList , VarDeclList;


Program ::= (Program) PROG ProgName:p ConstVarDeclList LBRACE MethodDeclList RBRACE
            ;

ProgName ::= (ProgName) IDENT:pName
            ;

ConstVarDeclList ::= (VarDeclarations) ConstVarDeclList VarDecl
				|
				(ConstDeclarations) ConstVarDeclList ConstDecl
				|
				(NoConstVarDecl)/* epsilon */
				;
VarDecl ::= (VarDeclArray) Type:varType IDENT:varName ArrayBracks VarDeclListExtended SEMI
            ;

ArrayBracks ::= (IsArray) LBRACK RBRACK
                |
                (NoArray) /* epsilon */
                ;

VarDeclListExtended ::= (VarDecListExtendedYes) VarDeclListExtended COMMA IDENT ArrayBracks
                        |
                        (VarDecListExtendedNo) /* epsilon */
                        ;


Type ::= (Type) IDENT:typeName
         ;

ConstDecl ::= (ConstDeclNode) CONST Type IDENT EQUAL ConstType ConstDeclListExtended SEMI
              ;

ConstType ::= (ConstNumber) NUMBER
              |
              (ConstBool) BOOL
              |
              (ConstChar) CHAR
              ;

ConstDeclListExtended ::= (ConstDeclListExtendedVal) ConstDeclListExtended COMMA IDENT EQUAL ConstType
                           |
                           (NoConstDeclListExtended) /* epsilon */
                           ;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;

MethodDecl ::= (MethodDecl) MethodTypeName IDENT:methName
			   LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			   ;

VarDeclList ::= (VarDeclListYes) VarDeclList VarDecl
                |
                (VarDeclLIstNo) /* epsilon */
                ;

MethodTypeName ::= (MethodType) Type:retType
                    |
                    (MethodVoid) VOID
                    ;

FormPars ::= (FormParams) FormalParamList
             |
             (NoFormParam) /* epsilon */
             ;

FormalParamList ::= (FormalParamDecls) FormalParamDecl FormalParamListExtended
					;

FormalParamDecl ::= (FormalParamDecl) Type IDENT ArrayBracks;

FormalParamListExtended ::= (FormalParamListExtendedYes) FormalParamListExtended COMMA FormalParamDecl
                            |
                            (FormalParamListExtendedNo) /* epsilon */
                            ;

StatementList ::= (Statements) StatementList Statement
				  |
				  (NoStmt) /* epsilon */
				  ;

Statement ::= (Assignment) DesignatorStatement:dest SEMI
              |
              (ReturnStmtExpr) RETURN Expr SEMI
              |
              (ReturnStmtNoExpr) RETURN SEMI
			  |
			  (ReadStmt) READ LPAREN Designator RPAREN SEMI
			  |
			  (PrintStmt) PRINT LPAREN Expr:t RPAREN SEMI
			  ;

DesignatorStatement ::= (EqualDesStatement) Designator Assignop Expr:e
                        |
                        (IncDesStatement) Designator PLUS_PLUS
                        |
                        (DecDesStatement) Designator MINUS_MINUS
                        ;

Expr ::= (AddExpr) Minus Term:t AddopTermList
		 ;

Minus ::= (YesMinus) MINUS
          |
          (NoMinus) /* epsilon */
          ;

AddopTermList ::= (YesAddopTermList) AddopTermList Addop:a Term:t
                  |
                  (NoAddopTermList) /* epsilon */
                   ;

Term ::= (TermFactor) Factor:t MulopFactorList
         ;

MulopFactorList ::= (YesMulopFactorList) MulopFactorList Mulop:m Factor:f
                     |
                     (NoMulopFactorList) /* epsilon */
                     ;

/* ConstSectDecl ::= (ConstSectDeclNode) CONST Type:constType; */

Factor ::= (ConstTypeVal) ConstType
            |
		    (ExprLRPAREN) LPAREN Expr RPAREN
		    |
		    (NewType) NEW Type
		    |
		    (NewTypeExpr) NEW Type LBRACK Expr RBRACK
		    |
		    (DesignatorFactor) Designator
		    |
		    (DesignatorFactorExtended) Designator LPAREN RPAREN
		    ;

Designator ::= (DesignatorIdent) IDENT:name
               |
               (DesignatorIdentExtended) IDENT:name LBRACK Expr RBRACK
               ;

Assignop ::= (AssignopEqual) EQUAL
             |
             (AssignopAddopRight) AddopRight
             |
             (AssignopMulopRight) MulopRight
             ;

Addop ::= (AddopBasicLeft) AddopLeft
          |
          (AddopBasicRight) AddopRight
          ;

AddopLeft ::= (AddopLeftMinus) MINUS
              |
              (AddopLeftPlus) PLUS
              ;

AddopRight ::= (AddopRightPlusEqual) PLUS_EQUAL
               |
               (AddopRightMinusEqual) MINUS_EQUAL
               ;

Mulop ::= (MulopBasicLeft) MulopLeft
          |
          (MulopBasicRight) MulopRight
          ;

MulopLeft ::= (MulopLeftMul) MUL
              |
              (MulopLeftDiv) DIV
              |
              (MulopLeftMod) MOD
              ;

MulopRight ::= (MulopRightMulEqual) MUL_EQUAL
               |
               (MulopRightDivEqual) DIV_EQUAL
               |
               (MulopRightModEqual) MOD_EQUAL
               ;