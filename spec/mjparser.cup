package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PLUS , RPAREN , EQUAL , SEMI , RETURN , LPAREN , COMMA , PROG , PRINT
 , VOID , MINUS , MUL , DIV , MOD , LBRACK , RBRACK , READ , NEW , PLUS_PLUS ,
 MINUS_MINUS , LBRACE, CONST , RBRACE , PLUS_EQUAL , MINUS_EQUAL , MUL_EQUAL , DIV_EQUAL , MOD_EQUAL , CHAR;
terminal Integer NUMBER ;
terminal Boolean BOOL ;
terminal String IDENT ;

nonterminal MethodDeclList, VarDecl;
nonterminal FormalParamList, FormalParamDecl, FormPars, ActualPars, ActualParamList;
nonterminal StatementList, Statement, Addop;
nonterminal Unmatched, Matched , DesignatorStatement, Expr, Minus,
 AddopTermList, Term, MulopFactorList, ConstSectDecl,
  Assignop, AddopLeft, AddopRight, Mulop, MulopLeft, MulopRight;

nonterminal Program, ProgName, Designator, MethodDecl, MethodTypeName;
nonterminal Type, Factor, VarDeclList;


Program ::= (Program) PROG ProgName:p VarDeclList LBRACE MethodDeclList RBRACE
            ;

ProgName ::= (ProgName) IDENT:pName
            ;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl
				|
				(NoVarDecl)/* epsilon */
				;

VarDecl ::= (VarDecl) Type:varType IDENT:varName SEMI
            ;

Type ::= (Type) IDENT:typeName
         ;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;

MethodDecl ::= (MethodDecl) MethodTypeName
			   LPAREN FormPars RPAREN VarDeclList LBRACE StatementList RBRACE
			   ;

MethodTypeName ::= (MethodTypeName) Type:retType IDENT:methName
                    ;

FormPars ::= (FormParams) FormalParamList
             | (NoFormParam) /* epsilon */
             ;

FormalParamList ::= (FormalParamDecls) FormalParamList COMMA FormalParamDecl
					|
					(SingleFormalParamDecl) FormalParamDecl
					;

FormalParamDecl ::= (FormalParamDecl) Type IDENT ;

StatementList ::= (Statements) StatementList Statement
				  |
				  (NoStmt) /* epsilon */
				  ;

Statement ::= (Assignment) DesignatorStatement:dest SEMI
			  |
			  (ReadStmt) READ LPAREN Designator RPAREN SEMI
			  |
			  (PrintStmt) PRINT LPAREN Expr:t RPAREN SEMI
			  ;

DesignatorStatement ::= (EqualDesStatement) Designator Assignop Expr:e
                        |
                        (IncDesStatement) Designator PLUS_PLUS
                        |
                        (DecDesStatement) Designator MINUS_MINUS
                        ;

Expr ::= (AddExpr) Minus Term:t AddopTermList
		 ;

Minus ::= (YesMinus) MINUS
          |
          (NoMinus) /* epsilon */
          ;

AddopTermList ::= (YesAddopTermList) AddopTermList Addop:a Term:t
                  |
                  (NoAddopTermList) /* epsilon */
                   ;

Term ::= (TermFactor) Factor:t MulopFactorList
         ;

MulopFactorList ::= (YesMulopFactorList) MulopFactorList Mulop:m Factor:f
                     |
                     (NoMulopFactorList) /* epsilon */
                     ;

ConstSectDecl ::= (ConstSectDeclNode) CONST Type:constType;

Factor ::= (ConstNumber) NUMBER
			|
			(ConstBool) BOOL
			|
			(ConstChar) CHAR
			|
		    (ExprLRPAREN) LPAREN Expr RPAREN
		    |
		    (NewType) NEW Type
		    |
		    (NewTypeExtended) NEW Type LBRACK Expr RBRACK
		    |
		    (DesignatorFactor) Designator
		    |
		    (DesignatorFactorExtended) Designator LPAREN RPAREN
		    ;

Designator ::= (DesignatorIdent) IDENT:name
               |
               (DesignatorIdentExtended) IDENT:name LBRACK Expr RBRACK
               ;

Assignop ::= (AssignopEqual) EQUAL
             |
             (AssignopAddopRight) AddopRight
             |
             (AssignopMulopRight) MulopRight
             ;

Addop ::= (AddopBasicLeft) AddopLeft
          |
          (AddopBasicRight) AddopRight
          ;

AddopLeft ::= (AddopLeftMinus) MINUS
              |
              (AddopLeftPlus) PLUS
              ;

AddopRight ::= (AddopRightPlusEqual) PLUS_EQUAL
               |
               (AddopRightMinusEqual) MINUS_EQUAL
               ;

Mulop ::= (MulopBasicLeft) MulopLeft
          |
          (MulopBasicRight) MulopRight
          ;

MulopLeft ::= (MulopLeftMul) MUL
              |
              (MulopLeftDiv) DIV
              |
              (MulopLeftMod) MOD
              ;

MulopRight ::= (MulopRightMulEqual) MUL_EQUAL
               |
               (MulopRightDivEqual) DIV_EQUAL
               |
               (MulopRightModEqual) MOD_EQUAL
               ;