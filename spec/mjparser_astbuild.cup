package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PLUS , RPAREN , EQUAL , SEMI , RETURN , LPAREN , COMMA , PROG , PRINT
 , VOID , MINUS , MUL , DIV , MOD , LBRACK , RBRACK , READ , NEW , PLUS_PLUS , CONST ,
 MINUS_MINUS , LBRACE , RBRACE , PLUS_EQUAL , MINUS_EQUAL , MUL_EQUAL , DIV_EQUAL , MOD_EQUAL , CHAR;
terminal Integer NUMBER ;
terminal Boolean BOOL ;
terminal String IDENT ;

nonterminal MethodDeclList MethodDeclList;
nonterminal VarDecl VarDecl ;
nonterminal ConstDecl ConstDecl ;
nonterminal FormalParamList FormalParamList;
nonterminal FormalParamDecl FormalParamDecl;
nonterminal FormPars FormPars;
nonterminal ActualPars ActualPars;
nonterminal ActualParamList ActualParamList;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal Addop Addop ;
nonterminal ArrayBracks ArrayBracks ;
nonterminal FormalParamListExtended FormalParamListExtended;
nonterminal Unmatched Unmatched;
nonterminal Matched Matched ;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal Expr Expr;
nonterminal Minus Minus;
nonterminal VarDeclListExtended VarDeclListExtended ;
nonterminal
AddopTermList AddopTermList;
nonterminal Term Term;
nonterminal MulopFactorList MulopFactorList;
nonterminal ConstSectDecl ConstSectDecl;
nonterminal ConstType ConstType ;
nonterminal ConstDeclListExtended ConstDeclListExtended ;
nonterminal
Assignop Assignop;
nonterminal AddopLeft AddopLeft;
nonterminal AddopRight AddopRight;
nonterminal Mulop Mulop;
nonterminal MulopLeft MulopLeft;
nonterminal MulopRight MulopRight;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName , VarDeclList;
nonterminal Type Type;
nonterminal Factor Factor;
nonterminal ConstVarDeclList ConstVarDeclList;


Program ::= (Program) PROG ProgName:p ConstVarDeclList:C1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(p, C1, M2); RESULT.setLine(pleft); :}
            ;

ProgName ::= (ProgName) IDENT:pName {: RESULT=new ProgName(pName); RESULT.setLine(pNameleft); :}
            ;

ConstVarDeclList ::= (VarDeclarations) ConstVarDeclList:C1 VarDecl:V2 {: RESULT=new VarDeclarations(C1, V2); RESULT.setLine(C1left); :}
				|
				(ConstDeclarations) ConstVarDeclList:C1 ConstDecl:C2 {: RESULT=new ConstDeclarations(C1, C2); RESULT.setLine(C1left); :}
				|
				(NoConstVarDecl) {: RESULT=new NoConstVarDecl(); :}/* epsilon */
				;
VarDecl ::= (VarDeclArray) Type:varType IDENT:varName ArrayBracks:A1 VarDeclListExtended:V2 SEMI {: RESULT=new VarDeclArray(varType, varName, A1, V2); RESULT.setLine(varTypeleft); :}
            ;

ArrayBracks ::= (IsArray) LBRACK RBRACK {: RESULT=new IsArray(); :}
                |
                (NoArray) {: RESULT=new NoArray(); :} /* epsilon */
                ;

VarDeclListExtended ::= (VarDecListExtendedYes) VarDeclListExtended:V1 COMMA IDENT:I2 ArrayBracks:A3 {: RESULT=new VarDecListExtendedYes(V1, I2, A3); RESULT.setLine(V1left); :}
                        |
                        (VarDecListExtendedNo) {: RESULT=new VarDecListExtendedNo(); :} /* epsilon */
                        ;


Type ::= (Type) IDENT:typeName {: RESULT=new Type(typeName); RESULT.setLine(typeNameleft); :}
         ;

ConstDecl ::= (ConstDeclNode) CONST Type:T1 IDENT:I2 EQUAL ConstType:C3 ConstDeclListExtended:C4 SEMI {: RESULT=new ConstDeclNode(T1, I2, C3, C4); RESULT.setLine(T1left); :}
              ;

ConstType ::= (ConstNumber) NUMBER:N1 {: RESULT=new ConstNumber(N1); RESULT.setLine(N1left); :}
              |
              (ConstBool) BOOL:B1 {: RESULT=new ConstBool(B1); RESULT.setLine(B1left); :}
              |
              (ConstChar) CHAR {: RESULT=new ConstChar(); :}
              ;

ConstDeclListExtended ::= (ConstDeclListExtendedVal) ConstDeclListExtended:C1 COMMA IDENT:I2 EQUAL ConstType:C3 {: RESULT=new ConstDeclListExtendedVal(C1, I2, C3); RESULT.setLine(C1left); :}
                           |
                           (NoConstDeclListExtended) {: RESULT=new NoConstDeclListExtended(); :} /* epsilon */
                           ;

MethodDeclList ::= (MethodDeclarations) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclarations(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMethodDecl) {: RESULT=new NoMethodDecl(); :}/* epsilon */
					;

MethodDecl ::= (MethodDecl) MethodTypeName:M1 IDENT:methName
			   LPAREN FormPars:F2 RPAREN VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(M1, methName, F2, V3, S4); RESULT.setLine(M1left); :}
			   ;

VarDeclList ::= (VarDeclListYes) VarDeclList:V1 VarDecl:V2 {: RESULT=new VarDeclListYes(V1, V2); RESULT.setLine(V1left); :}
                |
                (VarDeclLIstNo) {: RESULT=new VarDeclLIstNo(); :} /* epsilon */
                ;

MethodTypeName ::= (MethodType) Type:retType {: RESULT=new MethodType(retType); RESULT.setLine(retTypeleft); :}
                    |
                    (MethodVoid) VOID {: RESULT=new MethodVoid(); :}
                    ;

FormPars ::= (FormParams) FormalParamList:F1 {: RESULT=new FormParams(F1); RESULT.setLine(F1left); :}
             |
             (NoFormParam) {: RESULT=new NoFormParam(); :} /* epsilon */
             ;

FormalParamList ::= (FormalParamDecls) FormalParamDecl:F1 FormalParamListExtended:F2 {: RESULT=new FormalParamDecls(F1, F2); RESULT.setLine(F1left); :}
					;

FormalParamDecl ::= (FormalParamDecl) Type:T1 IDENT:I2 ArrayBracks:A3 {: RESULT=new FormalParamDecl(T1, I2, A3); RESULT.setLine(T1left); :};

FormalParamListExtended ::= (FormalParamListExtendedYes) FormalParamListExtended:F1 COMMA FormalParamDecl:F2 {: RESULT=new FormalParamListExtendedYes(F1, F2); RESULT.setLine(F1left); :}
                            |
                            (FormalParamListExtendedNo) {: RESULT=new FormalParamListExtendedNo(); :} /* epsilon */
                            ;

StatementList ::= (Statements) StatementList:S1 Statement:S2 {: RESULT=new Statements(S1, S2); RESULT.setLine(S1left); :}
				  |
				  (NoStmt) {: RESULT=new NoStmt(); :} /* epsilon */
				  ;

Statement ::= (Assignment) DesignatorStatement:dest SEMI {: RESULT=new Assignment(dest); RESULT.setLine(destleft); :}
              |
              (ReturnStmtExpr) RETURN Expr:E1 SEMI {: RESULT=new ReturnStmtExpr(E1); RESULT.setLine(E1left); :}
              |
              (ReturnStmtNoExpr) RETURN SEMI {: RESULT=new ReturnStmtNoExpr(); :}
			  |
			  (ReadStmt) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadStmt(D1); RESULT.setLine(D1left); :}
			  |
			  (PrintStmt) PRINT LPAREN Expr:t RPAREN SEMI {: RESULT=new PrintStmt(t); RESULT.setLine(tleft); :}
			  ;

DesignatorStatement ::= (EqualDesStatement) Designator:D1 Assignop:A2 Expr:e {: RESULT=new EqualDesStatement(D1, A2, e); RESULT.setLine(D1left); :}
                        |
                        (IncDesStatement) Designator:D1 PLUS_PLUS {: RESULT=new IncDesStatement(D1); RESULT.setLine(D1left); :}
                        |
                        (DecDesStatement) Designator:D1 MINUS_MINUS {: RESULT=new DecDesStatement(D1); RESULT.setLine(D1left); :}
                        ;

Expr ::= (AddExpr) Minus:M1 Term:t AddopTermList:A2 {: RESULT=new AddExpr(M1, t, A2); RESULT.setLine(M1left); :}
		 ;

Minus ::= (YesMinus) MINUS {: RESULT=new YesMinus(); :}
          |
          (NoMinus) {: RESULT=new NoMinus(); :} /* epsilon */
          ;

AddopTermList ::= (YesAddopTermList) AddopTermList:A1 Addop:a Term:t {: RESULT=new YesAddopTermList(A1, a, t); RESULT.setLine(A1left); :}
                  |
                  (NoAddopTermList) {: RESULT=new NoAddopTermList(); :} /* epsilon */
                   ;

Term ::= (TermFactor) Factor:t MulopFactorList:M1 {: RESULT=new TermFactor(t, M1); RESULT.setLine(tleft); :}
         ;

MulopFactorList ::= (YesMulopFactorList) MulopFactorList:M1 Mulop:m Factor:f {: RESULT=new YesMulopFactorList(M1, m, f); RESULT.setLine(M1left); :}
                     |
                     (NoMulopFactorList) {: RESULT=new NoMulopFactorList(); :} /* epsilon */
                     ;

/* ConstSectDecl ::= (ConstSectDeclNode) CONST Type:constType; */

Factor ::= (ConstTypeVal) ConstType:C1 {: RESULT=new ConstTypeVal(C1); RESULT.setLine(C1left); :}
            |
		    (ExprLRPAREN) LPAREN Expr:E1 RPAREN {: RESULT=new ExprLRPAREN(E1); RESULT.setLine(E1left); :}
		    |
		    (NewType) NEW Type:T1 {: RESULT=new NewType(T1); RESULT.setLine(T1left); :}
		    |
		    (NewTypeExpr) NEW Type:T1 LBRACK Expr:E2 RBRACK {: RESULT=new NewTypeExpr(T1, E2); RESULT.setLine(T1left); :}
		    |
		    (DesignatorFactor) Designator:D1 {: RESULT=new DesignatorFactor(D1); RESULT.setLine(D1left); :}
		    |
		    (DesignatorFactorExtended) Designator:D1 LPAREN RPAREN {: RESULT=new DesignatorFactorExtended(D1); RESULT.setLine(D1left); :}
		    ;

Designator ::= (DesignatorIdent) IDENT:name {: RESULT=new DesignatorIdent(name); RESULT.setLine(nameleft); :}
               |
               (DesignatorIdentExtended) IDENT:name LBRACK Expr:E1 RBRACK {: RESULT=new DesignatorIdentExtended(name, E1); RESULT.setLine(nameleft); :}
               ;

Assignop ::= (AssignopEqual) EQUAL {: RESULT=new AssignopEqual(); :}
             |
             (AssignopAddopRight) AddopRight:A1 {: RESULT=new AssignopAddopRight(A1); RESULT.setLine(A1left); :}
             |
             (AssignopMulopRight) MulopRight:M1 {: RESULT=new AssignopMulopRight(M1); RESULT.setLine(M1left); :}
             ;

Addop ::= (AddopBasicLeft) AddopLeft:A1 {: RESULT=new AddopBasicLeft(A1); RESULT.setLine(A1left); :}
          |
          (AddopBasicRight) AddopRight:A1 {: RESULT=new AddopBasicRight(A1); RESULT.setLine(A1left); :}
          ;

AddopLeft ::= (AddopLeftMinus) MINUS {: RESULT=new AddopLeftMinus(); :}
              |
              (AddopLeftPlus) PLUS {: RESULT=new AddopLeftPlus(); :}
              ;

AddopRight ::= (AddopRightPlusEqual) PLUS_EQUAL {: RESULT=new AddopRightPlusEqual(); :}
               |
               (AddopRightMinusEqual) MINUS_EQUAL {: RESULT=new AddopRightMinusEqual(); :}
               ;

Mulop ::= (MulopBasicLeft) MulopLeft:M1 {: RESULT=new MulopBasicLeft(M1); RESULT.setLine(M1left); :}
          |
          (MulopBasicRight) MulopRight:M1 {: RESULT=new MulopBasicRight(M1); RESULT.setLine(M1left); :}
          ;

MulopLeft ::= (MulopLeftMul) MUL {: RESULT=new MulopLeftMul(); :}
              |
              (MulopLeftDiv) DIV {: RESULT=new MulopLeftDiv(); :}
              |
              (MulopLeftMod) MOD {: RESULT=new MulopLeftMod(); :}
              ;

MulopRight ::= (MulopRightMulEqual) MUL_EQUAL {: RESULT=new MulopRightMulEqual(); :}
               |
               (MulopRightDivEqual) DIV_EQUAL {: RESULT=new MulopRightDivEqual(); :}
               |
               (MulopRightModEqual) MOD_EQUAL {: RESULT=new MulopRightModEqual(); :}
               ;